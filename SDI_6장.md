## 요구사항
- ID는 유일해야 하고 정렬이 가능해야 한다.
- 64비트의 사이즈를 가진다. (UUID는 128비트)
- 시간이 흐를때마다 ID값이 커진다.
- ID는 숫자로만 이루어진다.
- 초당 1만개의 ID 생성이 가능해야 한다.


## 나의 설계는?
- Redis Cluster를 활요한 IDGenerator
- 키구조(64비트로 가정)  =>  timestamp + 일런번호
- 1초마다 일련번호가 갱신되는 구조
- Redis Incr 명령어에 위임 
- 클러스터로 구성되어 있으므로 일관성보장 + SPOF방지


## 알고리즘
1. 매초마다 특정키를 생성하고 Expire Time으로 1초로 설정
``` java
   String key = "callLimit:myApiKey:" + TIME;
   Long increment = ops.increment(key);
   redisTemplate.expire(key, 1, TimeUnit.SECONDS);
```   

2. 요청이 들어올때마다 해당 초의 키로 Incr 명령어 전송
``` java
   Long value = ops.increment(key);
   System.out.println("ID : " + idPrefix + "-" + value);
```   
   
3. 초가 변경되면 자연스럽게 직전초 키의 레디스가 제거됨
   - 1초에 한번씩 일련번호 리셋
   - 레디스 캐시도 제거됨 (공간절약)
   - 초당 1만건 이상의 ID 발행이 가능한가? (테스트해보니 불가능할듯... 클러스터의 성능에 죄우됨)

``` link
참고
https://redis.com/redis-best-practices/basic-rate-limiting/
```


## 실행결과

``` txt
-----------------------------------
23시 38분 30초에 발급된 ID
-----------------------------------
ID : 20220613-233830-1
ID : 20220613-233830-2
ID : 20220613-233830-3
... (생략) ...
ID : 20220613-233830-60
ID : 20220613-233830-61
ID : 20220613-233830-62

-----------------------------------
23시 38분 31초에 발급된 ID
-----------------------------------
ID : 20220613-233831-1
ID : 20220613-233831-2
ID : 20220613-233831-3
... (생략) ...
ID : 20220613-233831-150
ID : 20220613-233831-151
ID : 20220613-233831-152

-----------------------------------
23시 38분 32초에 발급된 ID
-----------------------------------
ID : 20220613-233832-1
ID : 20220613-233832-2
ID : 20220613-233832-3
... (생략) ...
ID : 20220613-233832-90
ID : 20220613-233832-91
ID : 20220613-233832-92

```

